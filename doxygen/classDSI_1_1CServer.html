<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>DSI: CServer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceDSI.html">DSI</a>::<a class="el" href="classDSI_1_1CServer.html">CServer</a>
  </div>
</div>
<div class="contents">
<h1>CServer Class Reference</h1><!-- doxytag: class="DSI::CServer" --><!-- doxytag: inherits="DSI::CBase" -->
<p><code>#include &quot;<a class="el" href="CServer_8hpp_source.html">dsi/CServer.hpp</a>&quot;</code></p>

<p>Inherits <a class="el" href="classDSI_1_1CBase.html">DSI::CBase</a>.</p>

<p><a href="classDSI_1_1CServer-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDSI_1_1CServer_1_1ClientConnection.html">ClientConnection</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDSI_1_1CServer_1_1Notification.html">Notification</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDSI_1_1CServer_1_1SessionData.html">SessionData</a></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#ad1f33dbb0e6a4f9f6ea215c3e1e164b0">CServer</a> (const char *ifname, const char *rolename, int majorVerion, int minorVersion, bool enableTCPIP=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#ab6299b6c375e5d1a82653ce42e79be3e">setUserGroup</a> (const std::string &amp;groupName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#a1141315bab959464c764976390ca9e87">isTCPIPEnabled</a> ()</td></tr>
<tr><td colspan="2"><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d0b20e24cdbde88de8023809a4cab80"></a><!-- doxytag: member="DSI::CServer::clientconnectionlist_type" ref="a4d0b20e24cdbde88de8023809a4cab80" args="" -->
typedef std::set<br class="typebreak"/>
&lt; <a class="el" href="structDSI_1_1CServer_1_1ClientConnection.html">ClientConnection</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>clientconnectionlist_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a930dd3503199f681a23f1017fbd98673"></a><!-- doxytag: member="DSI::CServer::unblockedsessionsmap_type" ref="a930dd3503199f681a23f1017fbd98673" args="" -->
typedef std::map&lt; int32_t, <br class="typebreak"/>
<a class="el" href="structDSI_1_1CServer_1_1Notification.html">Notification</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>unblockedsessionsmap_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf0b7d23661de8c2be7be8f629d19079"></a><!-- doxytag: member="DSI::CServer::notificationlist_type" ref="aaf0b7d23661de8c2be7be8f629d19079" args="" -->
typedef std::vector&lt; <a class="el" href="structDSI_1_1CServer_1_1Notification.html">Notification</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>notificationlist_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afba0ee9f602f109c1c2df20f811b6f87"></a><!-- doxytag: member="DSI::CServer::sessionlist_type" ref="afba0ee9f602f109c1c2df20f811b6f87" args="" -->
typedef std::vector&lt; <a class="el" href="structDSI_1_1CServer_1_1SessionData.html">SessionData</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>sessionlist_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd5f4425d90c468e2fdad8792fcb1c6b"></a><!-- doxytag: member="DSI::CServer::activesessionlist_type" ref="afd5f4425d90c468e2fdad8792fcb1c6b" args="" -->
typedef std::set&lt; int32_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>activesessionlist_type</b></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#a5e61d470b1be68b6409251990b7713f9">unblockRequest</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unblock pending request, (prevent the server from beeing busy) by handling the response to a later point in time.  <a href="#a5e61d470b1be68b6409251990b7713f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#aef47975eca3bf5dff98b6d7ebdb8d6ef">prepareResponse</a> (int handle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepare the sending of a response to a listener which was unblocked.  <a href="#aef47975eca3bf5dff98b6d7ebdb8d6ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#a5641fd9e15be8ae051725c58e6a0b903">processRequest</a> (Private::CDataRequestHandle &amp;handle)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structDSI_1_1CServer_1_1ClientConnection.html">ClientConnection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#a5b8553962b821bb90a5e542ca226840a">findClientConnection</a> (const SPartyID &amp;clientId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#af9c5e55bbbfe96c7bf7372a82f333a13">findSessionId</a> (int32_t seqNr, const SPartyID &amp;clientID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#a6f74d6489bf103a1fd25a2368b880285">registerCurrentSession</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#aa1af78c2bfd0c930dba21f2378cc0d0e">addActiveSession</a> (int32_t sessionId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#a888f377b70a4683e7a5f9842f68c13bf">isSessionActive</a> (int32_t sessionId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#a35f687611dc29d4bb20b2a021ef1c8d1">clearActiveSessions</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#a3e24f247ae7b673837d141f47e2741c8">removeSession</a> (int32_t sessionId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#a1adaf782a193af9a0166e2e6b7e55990">sendNotification</a> (notificationid_t id, <a class="el" href="namespaceDSI.html#a0957e0df001dd796895b75f947daddb2">DSI::UpdateType</a> type=DSI::UPDATE_COMPLETE, int16_t position=-1, int16_t count=-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#a26285116fd00e5e006152569a8497cf7">removeNotification</a> (const SPartyID &amp;clientID, notificationid_t id=DSI::INVALID_ID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceDSI.html#a3d8fa5357d8d8f0e3224e5370feeed9f">DSI::DataStateType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#a8c885ef07c7d0f2a289f09aa5aa8cab9">getAttributeState</a> (uint32_t id)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d94c0f86950869a17ffb14215612026"></a><!-- doxytag: member="DSI::CServer::setAttributeState" ref="a1d94c0f86950869a17ffb14215612026" args="(uint32_t id, DSI::DataStateType)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#a1d94c0f86950869a17ffb14215612026">setAttributeState</a> (uint32_t id, <a class="el" href="namespaceDSI.html#a3d8fa5357d8d8f0e3224e5370feeed9f">DSI::DataStateType</a>)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets the state of the given attribute <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecdea22bb0712e2a64531823a29a981a"></a><!-- doxytag: member="DSI::CServer::writeAttribute" ref="aecdea22bb0712e2a64531823a29a981a" args="(uint32_t id, COStream &amp;ostream, DSI::UpdateType type, int16_t position, int16_t count)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#aecdea22bb0712e2a64531823a29a981a">writeAttribute</a> (uint32_t id, <a class="el" href="classDSI_1_1COStream.html">COStream</a> &amp;ostream, <a class="el" href="namespaceDSI.html#a0957e0df001dd796895b75f947daddb2">DSI::UpdateType</a> type, int16_t position, int16_t count)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">writes the attribute data to the given <a class="el" href="namespaceDSI.html">DSI</a> output stream <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#a0f3a2866931270455cd94e9f962f7c02">getResponse</a> (uint32_t requestId)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#a99477817c4abd0be1915a10aa1726231">getResponseState</a> (uint32_t responseId)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#afe7c4486f836c42696752c3a091ed06d">setResponseState</a> (uint32_t responseId, bool value)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a985f774a0105dd9b83826d44ea6efa13"></a><!-- doxytag: member="DSI::CServer::sendErrorToClient" ref="a985f774a0105dd9b83826d44ea6efa13" args="(const SPartyID &amp;clientID, uint32_t id, DSI::ResultType type, uint32_t seqNr)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>sendErrorToClient</b> (const SPartyID &amp;clientID, uint32_t id, <a class="el" href="namespaceDSI.html#aa71b5fc2a82d29a91db3a734ff892a49">DSI::ResultType</a> type, uint32_t seqNr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#a7ff593f3295154e5263c68dbaeb87c3f">sendResponse</a> (uint32_t responseId, uint32_t id, <a class="el" href="namespaceDSI.html#aa71b5fc2a82d29a91db3a734ff892a49">DSI::ResultType</a> type, uint32_t *err=0)</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ce48a73ba4a376d43d0ce3ecd9713a9"></a><!-- doxytag: member="DSI::CServer::mSessionId" ref="a1ce48a73ba4a376d43d0ce3ecd9713a9" args="" -->
int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#a1ce48a73ba4a376d43d0ce3ecd9713a9">mSessionId</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">id of the current active session <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e5536fd03cb54c36e605f5431cfaf71"></a><!-- doxytag: member="DSI::CServer::mResponseId" ref="a5e5536fd03cb54c36e605f5431cfaf71" args="" -->
uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#a5e5536fd03cb54c36e605f5431cfaf71">mResponseId</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">id of the next response (if any) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abeb5cd725d28347184179b1fead385ee"></a><!-- doxytag: member="DSI::CServer::mClientConnections" ref="abeb5cd725d28347184179b1fead385ee" args="" -->
clientconnectionlist_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#abeb5cd725d28347184179b1fead385ee">mClientConnections</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">list of all logical connections - as registerd by connect requests - to this server <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">notificationlist_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#a43d736b3fcf42eec3453ed8ec3685fc6">mNotifications</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unblockedsessionsmap_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#a6ce40404b0d8e3a277983775dd118a2c">mUnblockedSessions</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af54c7d13a48f7d5b1af06c073bf35293"></a><!-- doxytag: member="DSI::CServer::mSessions" ref="af54c7d13a48f7d5b1af06c073bf35293" args="" -->
sessionlist_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#af54c7d13a48f7d5b1af06c073bf35293">mSessions</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">list of all sessions <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#a00ac015be3c688f0c54799881fab6c10">mUserGroup</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SPartyID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDSI_1_1CServer.html#a56e07965b9d50151dae2c4001be81a6e">mTCPServerID</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa71f35a74f8f323579543b61116b14f"></a><!-- doxytag: member="DSI::CServer::d" ref="afa71f35a74f8f323579543b61116b14f" args="" -->
CPrivate *&nbsp;</td><td class="memItemRight" valign="bottom"><b>d</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The class <a class="el" href="classDSI_1_1CServer.html">CServer</a> is the base class of all server-side <a class="el" href="namespaceDSI.html">DSI</a> stubs. Other RPC mechanisms may use the wording 'skeleton' for a server. It serves as a base class for stubs generated by the <a class="el" href="namespaceDSI.html">DSI</a> code generator.</p>
<p>It provides generic methods for the <a class="el" href="namespaceDSI.html">DSI</a> communication. The actual stub implementation generated by the <a class="el" href="namespaceDSI.html">DSI</a> code generator provides all the interface specific parts of the communication by implementing the abstract interface methods.</p>
<p>This class is not intended to by used directly. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad1f33dbb0e6a4f9f6ea215c3e1e164b0"></a><!-- doxytag: member="DSI::CServer::CServer" ref="ad1f33dbb0e6a4f9f6ea215c3e1e164b0" args="(const char *ifname, const char *rolename, int majorVerion, int minorVersion, bool enableTCPIP=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDSI_1_1CServer.html">CServer</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ifname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>rolename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>majorVerion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>minorVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enableTCPIP</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new <a class="el" href="classDSI_1_1CServer.html">CServer</a> object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ifname</em>&nbsp;</td><td>the interface name of the service. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rolename</em>&nbsp;</td><td>the rolename of the component </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>majorVersion</em>&nbsp;</td><td>the major version of the interface </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>minorVersion</em>&nbsp;</td><td>the minor version of the interface </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enableTCPIP</em>&nbsp;</td><td>Enables TCPIP support for this server.</td></tr>
  </table>
  </dd>
</dl>
<p>If the service should be available within the network you must enable the TCP/IP mode. Beware, that in this mode, there is no access control currently implemented. Local services implement a rudimentary access control via the unix user-group (</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classDSI_1_1CServer.html#ab6299b6c375e5d1a82653ce42e79be3e">setUserGroup</a>). </dd></dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa1af78c2bfd0c930dba21f2378cc0d0e"></a><!-- doxytag: member="DSI::CServer::addActiveSession" ref="aa1af78c2bfd0c930dba21f2378cc0d0e" args="(int32_t sessionId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void addActiveSession </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>sessionId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the counterpart of <code>clearActiveSession</code>. Add the given sessionId to the list of active sessions. This must be called from the user-provided implementation in order to send out informations to the given described register session.</p>
<p>The standard use-case would be as follows: Within the register method the developer will call <code>registerCurrentSession</code> in order to get the current registration session id and store that id as key in a map with registration related parameters. In case, the correlated information is to be sent out, the code must place all suitable sessions within an active session by calling <code>clearActiveSessions</code> either before or after the information is sent out and of course <code>addActiveSession</code> to add the client to the list of recipients with appropriate clients' sessionIds. Then the appropriate information can be sent out. See this example:</p>
<div class="fragment"><pre class="fragment">



 <span class="keywordtype">void</span> registerRisingValue(int32_t highWatermark)
 {       
    mClients[<a class="code" href="classDSI_1_1CServer.html#a6f74d6489bf103a1fd25a2368b880285">registerCurrentSession</a>()] = highWatermark;
    checkWatermarks();
 }

 <span class="keywordtype">void</span> unregisterRisingValue(int32_t sessionID)
 {              
    mClients.erase(mClients.find(sessionID));
 }
 
 <span class="keywordtype">void</span> checkWatermarks()
 {              
    <span class="keywordflow">for</span>(<span class="keyword">auto</span> it = mClients.begin(); it != mClients.end(); ++it)
    {
       <span class="keywordflow">if</span> ((*it).second &lt;= getCurrentValue())
       {
          <a class="code" href="classDSI_1_1CServer.html#aa1af78c2bfd0c930dba21f2378cc0d0e">addActiveSession</a>((*it).first);
       }
    }

    informationRisedValue(getCurrentValue());
    <a class="code" href="classDSI_1_1CServer.html#a35f687611dc29d4bb20b2a021ef1c8d1">clearActiveSessions</a>();
 }       
</pre></div> 
</div>
</div>
<a class="anchor" id="a35f687611dc29d4bb20b2a021ef1c8d1"></a><!-- doxytag: member="DSI::CServer::clearActiveSessions" ref="a35f687611dc29d4bb20b2a021ef1c8d1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clearActiveSessions </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the counterpart of <code>addActiveSession</code>. Clear the list of active sessions. Typically, the implementor of a server must reset the list of active sessions for each new information to be sent out to registered clients either right after an information has been sent out or before a new information register session is to be filled with <code>addActiveSession</code>. </p>

</div>
</div>
<a class="anchor" id="a5b8553962b821bb90a5e542ca226840a"></a><!-- doxytag: member="DSI::CServer::findClientConnection" ref="a5b8553962b821bb90a5e542ca226840a" args="(const SPartyID &amp;clientId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structDSI_1_1CServer_1_1ClientConnection.html">ClientConnection</a>* findClientConnection </td>
          <td>(</td>
          <td class="paramtype">const SPartyID &amp;&nbsp;</td>
          <td class="paramname"> <em>clientId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks for the client connection to the client with the given clientId in mClientConnections and returns true if found, else false. </p>

</div>
</div>
<a class="anchor" id="af9c5e55bbbfe96c7bf7372a82f333a13"></a><!-- doxytag: member="DSI::CServer::findSessionId" ref="af9c5e55bbbfe96c7bf7372a82f333a13" args="(int32_t seqNr, const SPartyID &amp;clientID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t findSessionId </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>seqNr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SPartyID &amp;&nbsp;</td>
          <td class="paramname"> <em>clientID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find a session by the given sequence number and client-id. Sessions are created during the call of a REQUEST_REGISTER_NOTIFY. Afterwards the client sends a data request is sent to transport all register related user-data to the server. </p>

</div>
</div>
<a class="anchor" id="a8c885ef07c7d0f2a289f09aa5aa8cab9"></a><!-- doxytag: member="DSI::CServer::getAttributeState" ref="a8c885ef07c7d0f2a289f09aa5aa8cab9" args="(uint32_t id)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceDSI.html#a3d8fa5357d8d8f0e3224e5370feeed9f">DSI::DataStateType</a> getAttributeState </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the state of the given attribute. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f3a2866931270455cd94e9f962f7c02"></a><!-- doxytag: member="DSI::CServer::getResponse" ref="a0f3a2866931270455cd94e9f962f7c02" args="(uint32_t requestId)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t getResponse </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>requestId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the update id of the response to the given request, if there is one. otherwise returns DSI::INVALID_ID. </dd></dl>

</div>
</div>
<a class="anchor" id="a99477817c4abd0be1915a10aa1726231"></a><!-- doxytag: member="DSI::CServer::getResponseState" ref="a99477817c4abd0be1915a10aa1726231" args="(uint32_t responseId)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool getResponseState </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>responseId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the server has a pending response on the given responseId, else false. </dd></dl>

</div>
</div>
<a class="anchor" id="a888f377b70a4683e7a5f9842f68c13bf"></a><!-- doxytag: member="DSI::CServer::isSessionActive" ref="a888f377b70a4683e7a5f9842f68c13bf" args="(int32_t sessionId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isSessionActive </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>sessionId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks if the given is in the given sessionId is in the list of active sessions. This function will be called from within generated code in order to send an information to all registered clients. </p>

</div>
</div>
<a class="anchor" id="a1141315bab959464c764976390ca9e87"></a><!-- doxytag: member="DSI::CServer::isTCPIPEnabled" ref="a1141315bab959464c764976390ca9e87" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isTCPIPEnabled </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the server supports receiving requests via TCP/IP transport. </dd></dl>

</div>
</div>
<a class="anchor" id="aef47975eca3bf5dff98b6d7ebdb8d6ef"></a><!-- doxytag: member="DSI::CServer::prepareResponse" ref="aef47975eca3bf5dff98b6d7ebdb8d6ef" args="(int handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prepareResponse </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare the sending of a response to a listener which was unblocked. </p>
<p>After calling this method you have to call the adequate response method. There must not be any pending current response otherwise you will run into an assertion.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>handle for this request; this must be a valid identifier returned by a prior call to <a class="el" href="classDSI_1_1CServer.html#a5e61d470b1be68b6409251990b7713f9" title="Unblock pending request, (prevent the server from beeing busy) by handling the response...">unblockRequest()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classDSI_1_1CServer.html#a5e61d470b1be68b6409251990b7713f9" title="Unblock pending request, (prevent the server from beeing busy) by handling the response...">unblockRequest()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5641fd9e15be8ae051725c58e6a0b903"></a><!-- doxytag: member="DSI::CServer::processRequest" ref="a5641fd9e15be8ae051725c58e6a0b903" args="(Private::CDataRequestHandle &amp;handle)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void processRequest </td>
          <td>(</td>
          <td class="paramtype">Private::CDataRequestHandle &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This request handler will be provided by the code generator in order to allow calling user-provided request handlers. </p>

</div>
</div>
<a class="anchor" id="a6f74d6489bf103a1fd25a2368b880285"></a><!-- doxytag: member="DSI::CServer::registerCurrentSession" ref="a6f74d6489bf103a1fd25a2368b880285" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t registerCurrentSession </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the session id of the current register call. This method will only return a valid session id within the context of a register callback. Otherwise it will raise an assertion. </dd></dl>

</div>
</div>
<a class="anchor" id="a26285116fd00e5e006152569a8497cf7"></a><!-- doxytag: member="DSI::CServer::removeNotification" ref="a26285116fd00e5e006152569a8497cf7" args="(const SPartyID &amp;clientID, notificationid_t id=DSI::INVALID_ID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removeNotification </td>
          <td>(</td>
          <td class="paramtype">const SPartyID &amp;&nbsp;</td>
          <td class="paramname"> <em>clientID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">notificationid_t&nbsp;</td>
          <td class="paramname"> <em>id</em> = <code>DSI::INVALID_ID</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes notification of the given client. </p>

</div>
</div>
<a class="anchor" id="a3e24f247ae7b673837d141f47e2741c8"></a><!-- doxytag: member="DSI::CServer::removeSession" ref="a3e24f247ae7b673837d141f47e2741c8" args="(int32_t sessionId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removeSession </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>sessionId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Will be called from within generated code on an unregistration register call. </p>

</div>
</div>
<a class="anchor" id="a1adaf782a193af9a0166e2e6b7e55990"></a><!-- doxytag: member="DSI::CServer::sendNotification" ref="a1adaf782a193af9a0166e2e6b7e55990" args="(notificationid_t id, DSI::UpdateType type=DSI::UPDATE_COMPLETE, int16_t position=&#45;1, int16_t count=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sendNotification </td>
          <td>(</td>
          <td class="paramtype">notificationid_t&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDSI.html#a0957e0df001dd796895b75f947daddb2">DSI::UpdateType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em> = <code>DSI::UPDATE_COMPLETE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&nbsp;</td>
          <td class="paramname"> <em>position</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&nbsp;</td>
          <td class="paramname"> <em>count</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends out attribute change notifications to all listeners. </p>

</div>
</div>
<a class="anchor" id="a7ff593f3295154e5263c68dbaeb87c3f"></a><!-- doxytag: member="DSI::CServer::sendResponse" ref="a7ff593f3295154e5263c68dbaeb87c3f" args="(uint32_t responseId, uint32_t id, DSI::ResultType type, uint32_t *err=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sendResponse </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>responseId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceDSI.html#aa71b5fc2a82d29a91db3a734ff892a49">DSI::ResultType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>err</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send (error) response, the "Error" enum will be converted to uint32_t within the generated code. If <code>err</code> is not null, then the corresponding value will be sent. </p>

</div>
</div>
<a class="anchor" id="afe7c4486f836c42696752c3a091ed06d"></a><!-- doxytag: member="DSI::CServer::setResponseState" ref="afe7c4486f836c42696752c3a091ed06d" args="(uint32_t responseId, bool value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setResponseState </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>responseId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Notify the server whether the server has to send out a response with the given responseId somewhen in the future, i.e. the response is supposed to be dangling ( equals true) or not ( equals false). </p>

</div>
</div>
<a class="anchor" id="ab6299b6c375e5d1a82653ce42e79be3e"></a><!-- doxytag: member="DSI::CServer::setUserGroup" ref="ab6299b6c375e5d1a82653ce42e79be3e" args="(const std::string &amp;groupName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setUserGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>groupName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set a usergroup that is allowed to connect to this server. By default all users are allowed to connect. The user group must exist in the /etc/group file.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>groupName</em>&nbsp;</td><td>The name of the group the user must belong to to connect to this server.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Calling this function has influence on the servicebroker registration of the service. Hence it is necessary to call this method before adding the server to the communication engine and therefore registering the server at the servicebroker.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classDSI_1_1CServer.html#a00ac015be3c688f0c54799881fab6c10">mUserGroup</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5e61d470b1be68b6409251990b7713f9"></a><!-- doxytag: member="DSI::CServer::unblockRequest" ref="a5e61d470b1be68b6409251990b7713f9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unblockRequest </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unblock pending request, (prevent the server from beeing busy) by handling the response to a later point in time. </p>
<p>Unblocking a pending request means that you will not send a response within the request handler of your server implementation but you defer the sending of the response by calling <code>prepareResponse</code> with the returned handle before calling a response function to a later point of time.</p>
<p>A similar behaviour can be achieved by not sending any reponse or error within the request handler. The requestor will retrieve the corresponding response the next time the response is sent out by the server from within any other function. In the meantime the request is blocked for any further callers. They will immediately get a request...Failed callback called with the argument set to <code><a class="el" href="namespaceDSI.html#aa71b5fc2a82d29a91db3a734ff892a49a7119d0c787483f71e2f944deb7da0b12" title="A call to this request has already been received but the response has not yet been...">DSI::RESULT_REQUEST_BUSY</a></code>. There is no automatic retry or request caching mechanism, the implementor of the client has to resubmit the request to a later point in time. On server side, the corresponding request handler will not be called until the dangling response is sent out.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a unique handle for this request. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classDSI_1_1CServer.html#aef47975eca3bf5dff98b6d7ebdb8d6ef" title="Prepare the sending of a response to a listener which was unblocked.">prepareResponse</a> </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a43d736b3fcf42eec3453ed8ec3685fc6"></a><!-- doxytag: member="DSI::CServer::mNotifications" ref="a43d736b3fcf42eec3453ed8ec3685fc6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">notificationlist_type <a class="el" href="classDSI_1_1CServer.html#a43d736b3fcf42eec3453ed8ec3685fc6">mNotifications</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>List of all set notifications - a request/response pair will insert a temporary notification before calling the user-provided handle function and will drop it again afterwards. </p>

</div>
</div>
<a class="anchor" id="a56e07965b9d50151dae2c4001be81a6e"></a><!-- doxytag: member="DSI::CServer::mTCPServerID" ref="a56e07965b9d50151dae2c4001be81a6e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPartyID <a class="el" href="classDSI_1_1CServer.html#a56e07965b9d50151dae2c4001be81a6e">mTCPServerID</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>serverID of the tcp ip connection - as given by the servicebroker during registration so beware that this member is mutable. </p>

</div>
</div>
<a class="anchor" id="a6ce40404b0d8e3a277983775dd118a2c"></a><!-- doxytag: member="DSI::CServer::mUnblockedSessions" ref="a6ce40404b0d8e3a277983775dd118a2c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unblockedsessionsmap_type <a class="el" href="classDSI_1_1CServer.html#a6ce40404b0d8e3a277983775dd118a2c">mUnblockedSessions</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calling <code>unblockRequest</code> during a request handler will insert an entry into this map. <code>prepareResponse</code> will drop the entry again. </p>

</div>
</div>
<a class="anchor" id="a00ac015be3c688f0c54799881fab6c10"></a><!-- doxytag: member="DSI::CServer::mUserGroup" ref="a00ac015be3c688f0c54799881fab6c10" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classDSI_1_1CServer.html#a00ac015be3c688f0c54799881fab6c10">mUserGroup</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The unix group name of the group that is allowed to connect to this server. Note that the group membership is only used during servicebroker registration so the effective group will be checked by the servicebroker when a client tries to attach the interface. In case of missing membership the servicebroker will not provide the client with the appropriate data necessary to attach the interface (socket name for local socket) so brute force attacks could still allow to connect a local <a class="el" href="namespaceDSI.html">DSI</a> service even if the user-group does not fit.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>TCP/IP servers do not provide user-group specific access control. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="CServer_8hpp_source.html">CServer.hpp</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Mar 21 12:43:34 2012 for DSI by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
