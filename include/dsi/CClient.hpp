/*****************************************************************
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this file,
* You can obtain one at http://mozilla.org/MPL/2.0/.
* Copyright (c) 2012 Harman International Industries, Inc.
* All rights reserved
****************************************************************/
#ifndef DSI_CCLIENT_HPP
#define DSI_CCLIENT_HPP

#include "dsi/CBase.hpp"
#include "dsi/CChannel.hpp"


namespace DSI
{

   // forward decl
   class CConnectRequestHandle;

   namespace Private
   {
      class CDataResponseHandle;
   }


   /**
    * @class CClient "CClient.hpp" "dsi/CClient.hpp"
    *
    * The class CClient is the base class for all DSI Proxies. It handles
    * the generic part of the DSI communication. The actual proxy must
    * implement processResponse() for deserializing DSI data.
    */
   class CClient : public CBase
   {
      friend class ConnectionResetter;
      friend class CCommEngine;
      friend class CClientConnectSM;

   public:

      /**
       * Creates a new CClient object.
       *
       * @param ifname The interface name of the service to connect to.
       * @param rolename The rolename of the component.
       * @param majorVersion The major version of the interface.
       * @param minorVersion The minor version of the interface.
       */
      CClient(const char* ifname, const char* rolename, int majorVerion, int minorVersion);

      /**
       * The Destructor. Clean-up code.
       */
      ~CClient();

      /**
       * Clears all notifications.
       */
      void clearAllNotifications();

      /**
       * Are we connected to the server? The client only has valid client id and server id set
       * when it is actually connected since these IDs are generated by the servicebroker and
       * are retrieved by the client via attach calls to the servicebroker.
       */
      inline
      bool isConnected() const
      {
         return mClientID && mServerID && !mChannel.expired();
      }

   protected:

      /**
       * Sets a notification on an attribute, a response or an information.
       */
      void setNotification( notificationid_t id );

      /**
       * Clears the notification with the given update id.
       */
      void clearNotification( notificationid_t id );

      /**
       * Callback that is called when the server connects. This
       * function will be implemented by the generated proxy base class.
       */
      virtual void doComponentConnected() = 0;

      /**
       * Callback that is called when the server disconnects. This
       * function will be implemented by the generated proxy base class.
       */
      virtual void doComponentDisconnected() = 0;

      /// Callback that is called for Responses from the server.
      virtual void processResponse( Private::CDataResponseHandle &handle ) = 0 ;

      /// Handles the data responses from the server side. DSI protocol.
      void handleDataResponse( Private::CDataResponseHandle &handle );

      /// Sends disconnect requests messages to the server. DSI protocol.
      int sendDisconnectRequest();

      /// Sets a server available notification at the servicebroker. Servicebroker protocol.
      void setServerAvailableNotification( int32_t coockie );

      /// Removes the server available or server disconnect notification at the servicebroker.
      void removeNotification();

      /// Connects to the interface on the server and notifies servicebroker about that. DSI + Servicebroker protocol.
      void attachInterface();

      /// Disconnects to the interface on the server and notifies servicebroker about that. DSI + Servicebroker protocol.
      void detachInterface( bool resetNotification );

      /// handle response to connect request for local transport
      void handleConnectResponse(CConnectRequestHandle &handle);

      /**
       * The id of the currently set notification at the servicebroker. This can be a server available or
       * server disconnect notification depending on the state of the client, i.e. the client is attached to
       * the server or not.
       */
      notificationid_t mNotificationID;

      /// The channel to use for communication with the server.
      std::tr1::weak_ptr<CChannel> mChannel;

      /// Connecting a server is a multi-step operation with individual asynchronous steps. This
      /// pointer holds the object as long as a connection operation is in progress.
      std::unique_ptr<CClientConnectSM> mConnector;

      uint16_t mProtoMinor;

      /// pimpl extension point
      class CPrivate;
      CPrivate* d;
   };

} //namespace DSI


#endif // DSI_CCLIENT_HPP

