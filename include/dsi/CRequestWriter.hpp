/*****************************************************************
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this file,
* You can obtain one at http://mozilla.org/MPL/2.0/.
* Copyright (c) 2012 Harman International Industries, Inc.
* All rights reserved
****************************************************************/
#ifndef DSI_CREQUESTWRITER_HPP
#define DSI_CREQUESTWRITER_HPP

#include "dsi/DSI.hpp"
#include "dsi/CChannel.hpp"

#include "dsi/private/CNonCopyable.hpp"
#include "dsi/private/CBuffer.hpp"


namespace DSI
{

/**
 * Write one single DSI request. The writer combines both, a buffer interface and the
 * actual output channel. Therefore, it may be possible to use a shared memory segment
 * as buffer and send control messages via the channel. The current implementation
 * just uses a heap-based memory buffer sending the data via a socket-based channel.
 */
class CRequestWriter : public Private::CNonCopyable
{
public:

   CRequestWriter(CChannel& channel
                 , DSI::RequestType type
                 , DSI::Command cmd
                 , uint32_t id
                 , const SPartyID &clientID
                 , const SPartyID &serverID
                 , uint16_t proto_minor = DSI_PROTOCOL_VERSION_MINOR
                 , int32_t sequenceNr = DSI::INVALID_SEQUENCE_NR);       // FIXME get proto_minor from the channel
                
   CRequestWriter(CChannel& channel
                 , DSI::ResultType result
                 , DSI::Command cmd
                 , uint32_t id
                 , int32_t sequenceNr
                 , const SPartyID &clientID
                 , const SPartyID &serverID
                 , uint16_t proto_minor = DSI_PROTOCOL_VERSION_MINOR);      // FIXME get proto_minor from the channel
   
   CRequestWriter(CChannel& channel                 
                 , DSI::Command cmd                 
                 , const SPartyID &clientID
                 , const SPartyID &serverID
                 , uint16_t proto_minor = DSI_PROTOCOL_VERSION_MINOR);
                 
   /// testing purpose only constructor attaching to a dummy channel
   CRequestWriter();
   
   /// flushes the stream if not yet done
   inline
   ~CRequestWriter()
   {
      if (mHeader.type != 0)
         flush();
   }
   
   /**
    * @return the requests sequence number as set/generated by the constructor.
    */
   inline
   int32_t getSequenceNumber() const
   {
      return mInfo.sequenceNumber;
   }    
   
   /**
    * @returns a put pointer where data can be written to. Make sure the buffer
    *          has enough space available before writing into it via e.g. memcpy.
    */
   inline
   char* pptr()
   {
      return mBuf.pptr();
   }
   
   /// Move (increment) the put pointer by the given @c count number of bytes.
   inline
   void pbump(size_t count)
   {
      mBuf.pbump(count);
   }
   
   /// @return the current stream position, i.e. offset from beginning of the buffer.
   inline
   size_t size() const
   {
      return mBuf.size();
   }
   
   /// @return how many space is still available in the buffer.
   inline
   size_t avail() const
   {
      return mBuf.capacity() - mBuf.size();
   }
      
   /**
    * Make more space available by either writing out data or 
    * increasing buffer space (internal policy dependent).   
    *  
    * @param amount Minimum increment size for the new buffer.
    */
   inline
   void sbrk(size_t amount)
   {
      mBuf.setCapacity(mBuf.capacity() + amount);
   }
   
   /**
    * Finalize the current request by sending out all yet
    * unsent data. This can be called exactly once for each request object,
    * you must instantiate a new one if you want to send another request.
    */
   bool flush();
   
   /// Returns the buffer base pointer. For testing purpose only.
   inline
   const char* gptr() const
   {
      return mBuf.gptr();
   }
   
private:

   /// Connect and disconnect requests do not have an event info.
   inline
   bool haveEventInfo() const
   {
      return mHeader.cmd == DataRequest || mHeader.cmd == DataResponse;
   }
   
   /// Disconnect requests and normal requests may not have a payload.
   inline
   bool havePayload() const
   {
      return mBuf.size() > 0;
   }

   CChannel& mChannel;       ///< output channel

   MessageHeader mHeader;    ///< message header to be used for sending the request
   EventInfo mInfo;          ///< event information for data requests - may be unused for other request types

   Private::CBuffer mBuf;    ///< where to write the data to
};

}   // end namespace


#endif  // DSI_CREQUESTWRITER_HPP