/*****************************************************************
* This Source Code Form is subject to the terms of the Mozilla Public
* License, v. 2.0. If a copy of the MPL was not distributed with this file,
* You can obtain one at http://mozilla.org/MPL/2.0/.
* Copyright (c) 2012 Harman International Industries, Inc.
* All rights reserved
****************************************************************/
#ifndef DSI_CSERVER_HPP
#define DSI_CSERVER_HPP


#include "dsi/DSI.hpp"
#include "dsi/CBase.hpp"
#include "dsi/CChannel.hpp"

#include <string>
#include <map>
#include <vector>
#include <set>
#include <cassert>


namespace DSI
{

   class COStream;
   class CCommEngine;
   class CConnectRequestHandle;
   class CTCPConnectRequestHandle;

   namespace Private
   {
      class CDataRequestHandle;
   }

   /**
    * @class CServer "CServer.hpp" "dsi/CServer.hpp"
    *
    * The class CServer is the base class of all server-side DSI stubs. Other
    * RPC mechanisms may use the wording 'skeleton' for a server. It serves
    * as a base class for stubs generated by the DSI code generator.
    *
    * It provides generic methods for the DSI communication. The actual stub
    * implementation generated by the DSI code generator provides all the
    * interface specific parts of the communication by implementing the
    * abstract interface methods.
    *
    * This class is not intended to by used directly.
    */
   class CServer : public CBase
   {
      friend class ConnectionResetter;
      friend class CServicebroker;
      friend class CCommEngine;
      friend class FindByPartyID;

   public:

      /**
       * Creates a new CServer object.
       *
       * @param ifname the interface name of the service.
       * @param rolename the rolename of the component
       * @param majorVersion the major version of the interface
       * @param minorVersion the minor version of the interface
       * @param enableTCPIP Enables TCPIP support for this server.
       *
       * If the service should be available within the network you must enable the TCP/IP mode.
       * Beware, that in this mode, there is no access control currently implemented. Local
       * services implement a rudimentary access control via the unix user-group (@see setUserGroup).
       */
      CServer(const char* ifname, const char* rolename, int majorVerion, int minorVersion
             , bool enableTCPIP = false);

      ~CServer();

      /**
       * Set a usergroup that is allowed to connect to this server. By default
       * all users are allowed to connect. The user group must exist in the
       * /etc/group file.
       *
       * @param groupName The name of the group the user must belong to to connect
       *                  to this server.
       *
       * @note Calling this function has influence on the servicebroker registration of the
       *       service. Hence it is necessary to call this method before adding the server
       *       to the communication engine and therefore registering the server at the
       *       servicebroker.
       *
       * @see mUserGroup
       */
      inline
      void setUserGroup( const std::string& groupName )
      {
         mUserGroup = groupName;
      }

      /**
       * @return true if the server supports receiving requests via TCP/IP transport.
       */
      inline
      bool isTCPIPEnabled()
      {
         return mTCPIPEnabled ;
      }

   protected:

      /**
       * @brief Unblock pending request, (prevent the server from beeing busy) by handling
       *        the response to a later point in time.
       *
       * Unblocking a pending request means that you will not send a response within the request
       * handler of your server implementation but you defer the sending of the response by
       * calling @c prepareResponse with the returned handle before calling a response
       * function to a later point of time.
       *
       * A similar behaviour can be achieved by not sending any reponse or error within the request
       * handler. The requestor will retrieve the corresponding response the next time the response
       * is sent out by the server from within any other function. In the meantime the request is
       * blocked for any further callers. They will immediately get a request...Failed callback
       * called with the argument set to @c DSI::RESULT_REQUEST_BUSY. There is no automatic retry
       * or request caching mechanism, the implementor of the client has to resubmit the request to
       * a later point in time. On server side, the corresponding request handler will not be called
       * until the dangling response is sent out.
       *
       * @return a unique handle for this request.
       * @see prepareResponse
       */
      int unblockRequest();

      /**
       * @brief Prepare the sending of a response to a listener which was unblocked.
       *
       * After calling this method you have to call the adequate response method. There
       * must not be any pending current response otherwise you will run into an assertion.
       *
       * @param handle handle for this request; this must be a valid identifier returned
       *               by a prior call to unblockRequest()
       *
       * @see unblockRequest()
       */
      void prepareResponse(int handle);

      /**
       * This request handler will be provided by the code generator in order to
       * allow calling user-provided request handlers.
       */
      virtual void processRequest( Private::CDataRequestHandle &handle ) = 0 ;

      /**
       * ClientConnection stores the data that is needed to keep
       * a connection to a client. Each client connected to this
       * server has its own ClientConnection object.
       */
      struct ClientConnection
      {
         int32_t id;                      ///< the unique id of this connection

         SPartyID clientID;               ///< the client id of the connection
         SPartyID serverID;               ///< the server id of the connection

         notificationid_t notificationID; ///< the notification id used for the servicebroker
         std::tr1::weak_ptr<CChannel> channel;      ///< the transport connection
         uint16_t protoMinor;
         ClientConnection();

         /// std::set search
         explicit inline
         ClientConnection(SPartyID theClientID)
          : clientID(theClientID)
         {
            // NOOP
         }

         inline
         int32_t getId() const
         {
            return id;
         }

         /// std::set ordering
         inline
         bool operator<(const ClientConnection& rhs) const
         {
            return clientID.globalID < rhs.clientID.globalID;
         }
      } ;

      struct SessionData
      {

         int32_t sessionId;    ///< the session id for sessions
         SPartyID clientID;    ///< the id of the client that set the notification
         int32_t sequenceNr;   ///< the sequence number of this session
         uint32_t updateId;    ///< correlated updateId only used for register methods

         /// Create an invalid session data object.
         inline
         SessionData()
            : sessionId(INVALID_SESSION_ID)
            , sequenceNr(INVALID_SEQUENCE_NR)
            , updateId(INVALID_ID)
         {
            // NOOP
         }

         inline
         SessionData(const SessionData& rhs)
            : sessionId(rhs.sessionId)
            , clientID(rhs.clientID)
            , sequenceNr(rhs.sequenceNr)
         {
            // NOOP
         }
      };

      /**
       * @internal
       * stores notification specific data
       */
      struct Notification : public SessionData
      {
         notificationid_t notifyID;   ///< the notification id

         /// Create an invalid Notification object.
         inline
         Notification()
            : notifyID(INVALID_NOTIFICATION_ID)
         {
            // NOOP
         }

         inline
         Notification(const Notification& rhs)
            : SessionData(rhs)
            , notifyID(rhs.notifyID)
         {
            // NOOP
         }
      };

      /**
       * Looks for the client connection to the client with the given clientId
       * in mClientConnections and returns true if found, else false.
       */
      ClientConnection* findClientConnection(const SPartyID& clientId);
     
      /**
       * Find a session by the given sequence number and client-id. Sessions are created during the
       * call of a REQUEST_REGISTER_NOTIFY. Afterwards the client sends a data request to
       * transport all register related user-data to the server.
       *
       * @return a pointer to the session object if found, else 0.
       */
      SessionData* findSession(int32_t seqNr, const SPartyID &clientID);
      
      /**
       * @return the session id of the current register call. This method will only return a valid
       *         session id within the context of a register callback. Otherwise it will raise an
       *         assertion.
       */
      inline
      int32_t registerCurrentSession(void)
      {
         assert(mSessionId != DSI::INVALID_SESSION_ID);
         return mSessionId;
      }

      /**
       * This is the counterpart of @c clearActiveSession. Add the given sessionId to the list of 
       * active sessions. This must be called from the user-provided implementation in order to 
       * send out informations to the given described register session.
       * 
       * The standard use-case would be as follows: Within the register method the developer will
       * call @c registerCurrentSession in order to get the current registration session id and
       * store that id as key in a map with registration related parameters. In case, the correlated 
       * information is to be sent out, the code must place all suitable sessions within an active session
       * by calling @c clearActiveSessions either before or after the information is sent out and 
       * of course @c addActiveSession to add the client to the list of recipients with appropriate 
       * clients' sessionIds. Then the appropriate information can be sent out. See this example:
       *
       * @code
       * /// risingValue is a register method, the code generator creates register and unregister calls for you
       * /// currentValue is an attribute
       * /// risedValue is an information
       *
       * void registerRisingValue(int32_t highWatermark)
       * {       
       *    mClients[registerCurrentSession()] = highWatermark;
       *    checkWatermarks();
       * }
       *
       * void unregisterRisingValue(int32_t sessionID)
       * {              
       *    mClients.erase(mClients.find(sessionID));
       * }
       * 
       * void checkWatermarks()
       * {              
       *    for(auto it = mClients.begin(); it != mClients.end(); ++it)
       *    {
       *       if ((*it).second <= getCurrentValue())
       *       {
       *          addActiveSession((*it).first);
       *       }
       *    }
       *
       *    informationRisedValue(getCurrentValue());
       *    clearActiveSessions();
       * }       
       * @endcode
       */
      void addActiveSession(int32_t sessionId);

      /**
       * Checks if the given is in the given sessionId is in the list of active sessions. This function
       * will be called from within generated code in order to send an information to all registered clients.       
       */
      bool isSessionActive(int32_t sessionId);

      /**
       * This is the counterpart of @c addActiveSession. Clear the list of active sessions. 
       * Typically, the implementor of a server must reset the list of active
       * sessions for each new information to be sent out to registered clients either right
       * after an information has been sent out or before a new information register session is to be
       * filled with @c addActiveSession.
       */
      void clearActiveSessions();

      /**
       * Will be called on disconnect requests or transport deaths so all callback handlers will be 
       * evaluated.
       */
      virtual void removeAllSessions(const SPartyID& clientID) = 0;

      /**
       * Will be called from within generated code on an unregistration register call.
       */
      void removeSession(int32_t sessionId);
      
      /**
       * Sends out attribute change notifications to all listeners.
       */
      void sendNotification(notificationid_t id, DSI::UpdateType type = DSI::UPDATE_COMPLETE, int16_t position = -1, int16_t count = -1);

      /**
       * Removes notification of the given client.
       */
      void removeNotification(const SPartyID &clientID, notificationid_t id = DSI::INVALID_ID);

      /**
       * @return the state of the given attribute.
       */
      virtual DSI::DataStateType getAttributeState(uint32_t id) = 0 ;

      /// sets the state of the given attribute
      virtual void setAttributeState(uint32_t id, DSI::DataStateType) = 0 ;

      /// writes the attribute data to the given DSI output stream
      virtual void writeAttribute(uint32_t id, COStream& ostream, DSI::UpdateType type, int16_t position, int16_t count) = 0 ;

      /**
       * @return the update id of the response to the given request, if there is one.
       * otherwise returns DSI::INVALID_ID.
       */
      virtual uint32_t getResponse(uint32_t requestId) = 0 ;

      /**
       * @return true if the server has a pending response on the given responseId, else false.
       */
      virtual bool getResponseState(uint32_t responseId) = 0 ;

      /**
       * Notify the server whether the server has to send out a response with the given responseId somewhen in the
       * future, i.e. the response is supposed to be dangling (@value equals true) or not (@value equals false).
       */
      virtual void setResponseState(uint32_t responseId, bool value) = 0 ;

      void sendErrorToClient(const SPartyID &clientID, uint32_t id, DSI::ResultType type, uint32_t seqNr);

      /**
       * Send (error) response, the "Error" enum will be converted to uint32_t within the generated code.
       * If @c err is not null, then the corresponding value will be sent.
       */
      void sendResponse(uint32_t responseId, uint32_t id, DSI::ResultType type, uint32_t* err = nullptr);

      typedef std::set<ClientConnection> clientconnectionlist_type;
      typedef std::map<int32_t, Notification> unblockedsessionsmap_type;
      typedef std::vector<Notification> notificationlist_type;
      typedef std::vector<SessionData> sessionlist_type;
      typedef std::set<int32_t> activesessionlist_type;

      /// id of the current active session
      int32_t mSessionId ;

      /// id of the next response (if any)
      uint32_t mResponseId ;

      /// list of all logical connections - as registerd by connect requests - to this server
      clientconnectionlist_type mClientConnections ;

      /**
       * List of all set notifications - a request/response pair will insert a temporary notification
       * before calling the user-provided handle function and will drop it again afterwards.
       */
      notificationlist_type mNotifications ;

      /**
       * Calling @c unblockRequest during a request handler will insert an entry into this map.
       * @c prepareResponse will drop the entry again.
       */
      unblockedsessionsmap_type mUnblockedSessions ;

      /// list of all sessions
      sessionlist_type mSessions ;

      /**
       * The unix group name of the group that is allowed to connect to this server. Note that
       * the group membership is only used during servicebroker registration so the effective group
       * will be checked by the servicebroker when a client tries to attach the interface. In case
       * of missing membership the servicebroker will not provide the client with the appropriate
       * data necessary to attach the interface (socket name for local socket) so brute force attacks
       * could still allow to connect a local DSI service even if the user-group does not fit.
       *
       * @note TCP/IP servers do not provide user-group specific access control.
       */
      std::string mUserGroup;

      /**
       * serverID of the tcp ip connection - as given by the servicebroker during registration
       * so beware that this member is mutable.
       */
      SPartyID mTCPServerID;
      
      /// pimpl extension point
      class CPrivate;
      CPrivate* d;

   private:

      void cleanupClientConnection(const ClientConnection& c);
      
      /**
       * Handles DSI data requests from the client.
       */
      void handleDataRequest(Private::CDataRequestHandle &handle);

      /**
       * Handles the DSI disconnect request which is sent by a client during a graceful shutdown.
       */
      void handleDisconnectRequest(const SPartyID &clientID);

      /**
       * Handles a connect request message from a client that wants to connect to this server via local
       * transport.
       */
      void handleConnectRequest(CConnectRequestHandle& handle);

      /**
       * Handles a connect request message from a client that wants to connect to this server via TCP/IP
       * transport.
       */
      void handleConnectRequestTCP(CTCPConnectRequestHandle& handle);

      /**
       * Handles a connect request message from a legacy client that wants to connect to this server via TCP/IP
       * transport.
       */
      void handleLegacyConnectRequestTCP(CTCPConnectRequestHandle& handle);

      /**
       * Handles the client detach notification sent by the servicebroker when a client closes the
       * connection to the servicebroker or actively calls @c SBDetachInterface.
       */
      bool handleClientDetached(int id);

      /**
       * Registrate the server at the servicebroker for local transport.
       */
      void registerInterface( int32_t channel );

      /**
       * Registrate the server at the servicebroker for tcp transport.
       * @note In order to avoid race conditions the tcp service must always be
       * registrated before the local transport service.
       */
      void registerInterfaceTCP( uint32_t address, int32_t port );

      /**
       * Unregistrates the server at the servicebroker. This will be done for both local and
       * TCP transport.
       */
      void unregisterInterface();

      /**
       * Remove all unblocked sessions associated with the given clientID.
       */
      void removeUnblockedSessions(const SPartyID& clientID);
      
      /// list of all active sessions
      activesessionlist_type mActiveSessions;

      /// remove all notifications correlated with the given sessionId
      void removeSessionNotifications(int32_t sessionId);
      
      /// Is TCPIP support enabled?
      bool mTCPIPEnabled;
   };

}//namespace DSI

#endif   // DSI_CSERVER_HPP

